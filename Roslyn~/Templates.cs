namespace RefListRoslyn
{
    public static class Templates
    {
        public const string StaticApi = @"// Generated by RefListRoslyn
namespace DnDev
{{
    public static class {0}
    {{
        [NoCopyReturn]
        public static {0}<T> Empty<T>() where T : {1} => default;

        [NoCopyReturn]
        public static {0}<T> WithCapacity<T>(int capacity) where T : {1}
        {{
            var list = Empty<T>();
            list.SetBufferSize(capacity);
            return list;
        }}

        [NoCopyReturn]
        public static {0}<T> WithDefaultItems<T>(int count) where T : {1}
        {{
            var list = WithCapacity<T>(count);
            list.Count = count;
            return list;
        }}

        [NoCopyReturn]
        public static {0}<T> Move<T>(ref {0}<T> other) where T : {1}
        {{
            var list = new {0}<T>(other);
            other = default;
            return list;
        }}

        [NoCopyReturn]
        public static {0}<T> Copy<T>(in {0}<T> other) where T : {1}
        {{
            if (other.Count == 0)
                return default;

            var list = WithCapacity<T>(other.Count);
            list.CopyBufferItemsFrom(other);

            return list;
        }}
    }}
}}";

        public const string Extensions = @"// Generated by RefListRoslyn
using System;

namespace DnDev
{{
    public static class {0}Impl
    {{
        public static int Capacity<T>(this in {0}<T> self) where T : {1} => self.GetBufferSize();

        public static int Count<T>(this in {0}<T> self) where T : {1} => self.Count;

        public static void Dealloc<T>(this ref {0}<T> self) where T : {1} => self.SetBufferSize(0);

        public static ref readonly T RefReadonlyAt<T>(this in {0}<T> self, int index) where T : {1}
        {{
            if (index < 0 || index >= self.Count)
                throw new IndexOutOfRangeException();

            return ref self.IndexBuffer(index);
        }}

        public static ref T RefAt<T>(this ref {0}<T> self, int index) where T : {1}
        {{
            if (index < 0 || index >= self.Count)
                throw new IndexOutOfRangeException();

            return ref self.IndexBufferMut(index);
        }}

        public static void Add<T>(this ref {0}<T> self, in T item) where T : {1}
        {{
            self.EnsureCanAdd();
            self.IndexBufferMut(self.Count++) = item;
        }}

        public static ref T RefAdd<T>(this ref {0}<T> self) where T : {1}
        {{
            self.EnsureCanAdd();
            return ref self.IndexBufferMut(self.Count++);
        }}

        private static void EnsureCanAdd<T>(this ref {0}<T> self) where T : {1}
        {{
            if (self.Count < self.Capacity())
               return;

            var newSize = Math.Max(self.Capacity() * 2, 1);
            self.SetBufferSize(newSize);
        }}

        public static void RemoveAt<T>(this ref {0}<T> self, int index) where T : {1}
        {{
            if (index < 0 || index >= self.Count)
                throw new IndexOutOfRangeException();

            self.Count--;
            self.CopyWithinBuffer(index + 1, index, self.Count - index);
            self.IndexBufferMut(self.Count) = default;
        }}

        public static void Clear<T>(this ref {0}<T> self) where T : {1}
        {{
            if (self.Count == 0)
                return;

            self.ClearBuffer();
            self.Count = 0;
        }}

        public static void AppendDefault<T>(this ref {0}<T> self, int count) where T : {1}
        {{
            if (count < 0)
                throw new InvalidOperationException();

            var newCount = self.Count + count;

            if (self.Capacity() < newCount)
                self.SetBufferSize(newCount);

            self.Count = newCount;
        }}
    }}
}}";
    }
}