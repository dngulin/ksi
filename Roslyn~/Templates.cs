namespace RefListRoslyn
{
    public static class Templates
    {
        public const string StaticApi = @"// Generated by RefListRoslyn
namespace DnDev
{{
    public static class {0}
    {{
        [NoCopyReturn]
        public static {0}<T> Empty<T>() where T : {1} => default;

        [NoCopyReturn]
        public static {0}<T> WithCapacity<T>(int capacity) where T : {1}
        {{
            var list = Empty<T>();
            list.SetBufferSize(capacity);
            return list;
        }}

        [NoCopyReturn]
        public static {0}<T> WithDefaultItems<T>(int count) where T : {1}
        {{
            var list = WithCapacity<T>(count);
            list.Count = count;
            return list;
        }}

        [NoCopyReturn]
        public static {0}<T> Move<T>(ref {0}<T> other) where T : {1}
        {{
            var list = new {0}<T>(other);
            other = default;
            return list;
        }}
    }}
}}";

        public const string Extensions = @"// Generated by RefListRoslyn
using System;

namespace DnDev
{{
    public static class {0}Impl
    {{
        public static int Capacity<T>(this in {0}<T> self) where T : {1} => self.GetBufferSize();

        public static int Count<T>(this in {0}<T> self) where T : {1} => self.Count;

        public static void Dealloc<T>(this ref {0}<T> self) where T : {1} => self.SetBufferSize(0);

        public static ref readonly T RefReadonlyAt<T>(this in {0}<T> self, int index) where T : {1}
        {{
            if (index < 0 || index >= self.Count)
                throw new IndexOutOfRangeException();

            return ref self.IndexBuffer(index);
        }}

        public static ref T RefAt<T>(this ref {0}<T> self, int index) where T : {1}
        {{
            if (index < 0 || index >= self.Count)
                throw new IndexOutOfRangeException();

            return ref self.IndexBufferMut(index);
        }}

        public static void Add<T>(this ref {0}<T> self, in T item) where T : {1}
        {{
            self.EnsureCanAdd();
            self.IndexBufferMut(self.Count++) = item;
        }}

        public static ref T RefAdd<T>(this ref {0}<T> self) where T : {1}
        {{
            self.EnsureCanAdd();
            return ref self.IndexBufferMut(self.Count++);
        }}

        private static void EnsureCanAdd<T>(this ref {0}<T> self) where T : {1}
        {{
            if (self.Count < self.Capacity())
               return;

            var newSize = Math.Max(self.Capacity() * 2, 1);
            self.SetBufferSize(newSize);
        }}

        public static void RemoveAt<T>(this ref {0}<T> self, int index) where T : {1}
        {{
            if (index < 0 || index >= self.Count)
                throw new IndexOutOfRangeException();

            self.Count--;
            self.CopyWithinBuffer(index + 1, index, self.Count - index);
            self.IndexBufferMut(self.Count) = default;
        }}

        public static void Clear<T>(this ref {0}<T> self) where T : {1}
        {{
            if (self.Count == 0)
                return;

            self.ClearBuffer();
            self.Count = 0;
        }}

        public static void AppendDefault<T>(this ref {0}<T> self, int count) where T : {1}
        {{
            if (count < 0)
                throw new InvalidOperationException();

            var newCount = self.Count + count;

            if (self.Capacity() < newCount)
                self.SetBufferSize(newCount);

            self.Count = newCount;
        }}
    }}
}}";

        public const string Iterators = @"// Generated by RefListRoslyn
using System;

namespace DnDev
{{
    public static class {0}IteratorExtensions
    {{
        public static {0}ReadOnlyIterator<T> RefReadonlyIter<T>(this in {0}<T> self) where T : {1}
        {{
            return new {0}ReadOnlyIterator<T>(self.AsReadonlySpan());
        }}

        public static {0}Iterator<T> RefIter<T>(this ref {0}<T> self) where T : {1}
        {{
            return new {0}Iterator<T>(self.AsSpan());
        }}

        public static {0}ReadOnlyIteratorReversed<T> RefReadonlyIterReversed<T>(this in {0}<T> self) where T : {1}
        {{
            return new {0}ReadOnlyIteratorReversed<T>(self.AsReadonlySpan());
        }}

        public static {0}IteratorReversed<T> RefIterReversed<T>(this ref {0}<T> self) where T : {1}
        {{
            return new {0}IteratorReversed<T>(self.AsSpan());
        }}
    }}

    public readonly ref struct {0}Iterator<T> where T : {1}
    {{
        private readonly Span<T> _span;
        public {0}Iterator(in Span<T> span) => _span = span;
        public {0}Enumerator<T> GetEnumerator() => new {0}Enumerator<T>(_span);
    }}

    public ref struct {0}Enumerator<T> where T : {1}
    {{
        private Span<T> _span;
        private int _curr;

        public {0}Enumerator(in Span<T> span)
        {{
            _span = span;
            _curr = -1;
        }}

        public ref T Current => ref _span[_curr];
        public bool MoveNext() => ++_curr < _span.Length;
        public void Reset() => _curr = -1;
        public void Dispose() {{}}
    }}

    public readonly ref struct {0}ReadOnlyIterator<T> where T : {1}
    {{
        private readonly ReadOnlySpan<T> _span;
        public {0}ReadOnlyIterator(in ReadOnlySpan<T> span) => _span = span;
        public {0}ReadOnlyEnumerator<T> GetEnumerator() => new {0}ReadOnlyEnumerator<T>(_span);
    }}

    public ref struct {0}ReadOnlyEnumerator<T> where T : {1}
    {{
        private readonly ReadOnlySpan<T> _span;
        private int _curr;

        public {0}ReadOnlyEnumerator(in ReadOnlySpan<T> span)
        {{
            _span = span;
            _curr = -1;
        }}

        public ref readonly T Current => ref _span[_curr];
        public bool MoveNext() => ++_curr < _span.Length;
        public void Reset() => _curr = -1;
        public void Dispose() {{}}
    }}

    public readonly ref struct {0}IteratorReversed<T> where T : {1}
    {{
        private readonly Span<T> _span;
        public {0}IteratorReversed(in Span<T> span) => _span = span;
        public {0}EnumeratorReversed<T> GetEnumerator() => new {0}EnumeratorReversed<T>(_span);
    }}

    public ref struct {0}EnumeratorReversed<T> where T : {1}
    {{
        private Span<T> _span;
        private int _curr;

        public {0}EnumeratorReversed(in Span<T> span)
        {{
            _span = span;
            _curr = span.Length;
        }}

        public ref T Current => ref _span[_curr];
        public bool MoveNext() => --_curr >= 0;
        public void Reset() => _curr = -1;
        public void Dispose() {{}}
    }}

    public readonly ref struct {0}ReadOnlyIteratorReversed<T> where T : {1}
    {{
        private readonly ReadOnlySpan<T> _span;
        public {0}ReadOnlyIteratorReversed(in ReadOnlySpan<T> span) => _span = span;
        public {0}ReadOnlyEnumeratorReversed<T> GetEnumerator() => new {0}ReadOnlyEnumeratorReversed<T>(_span);
    }}

    public ref struct {0}ReadOnlyEnumeratorReversed<T> where T : {1}
    {{
        private readonly ReadOnlySpan<T> _span;
        private int _curr;

        public {0}ReadOnlyEnumeratorReversed(in ReadOnlySpan<T> span)
        {{
            _span = span;
            _curr = span.Length;
        }}

        public ref readonly T Current => ref _span[_curr];
        public bool MoveNext() => --_curr >= 0;
        public void Reset() => _curr = _span.Length;
        public void Dispose() {{}}
    }}
}}";

        public const string StringExt = @"// Generated by RefListRoslyn
using System;
using System.Text;

namespace DnDev
{{
    public static class {0}StringExtensions
    {{
        public static void AppendUtf8String(this ref {0}<byte> list, string value)
        {{
            if (string.IsNullOrEmpty(value))
                return;

            var pos = list.Count();
            var len = Encoding.UTF8.GetByteCount(value);

            list.AppendDefault(len);
            Encoding.UTF8.GetBytes(value.AsSpan(), list.AsSpan().Slice(pos, len));
        }}

        public static void AppendAsciiString(this ref {0}<byte> list, string value)
        {{
            if (string.IsNullOrEmpty(value))
                return;

            var pos = list.Count();
            var len = value.Length;

            list.AppendDefault(len);
            Encoding.ASCII.GetBytes(value.AsSpan(), list.AsSpan().Slice(pos, len));
        }}

        public static string ToStringUtf8(this in {0}<byte> list)
        {{
            return list.Count == 0 ? """" : Encoding.UTF8.GetString(list.AsReadonlySpan());
        }}

        public static string ToStringAscii(this in {0}<byte> list)
        {{
            return list.Count == 0 ? """" : Encoding.ASCII.GetString(list.AsReadonlySpan());
        }}
    }}
}}";
    }
}