using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace DnDev.Roslyn
{
    [Generator(LanguageNames.CSharp)]
    public class ExplicitCopyGenerator : IIncrementalGenerator
    {
        private const string ExplicitCopyApi = "ExplicitCopyApiAttribute";
        private const string UnmanagedList = "UnmanagedRefListAttribute";
        private const string DeallocApi = "DeallocApiAttribute";

        private class TypeInfo
        {
            public string TypeName;
            public string Namespace;
            public bool IsUnmanged;
            public bool HasDeallocAttribute;
            public string[] Usings = Array.Empty<string>();
            public readonly List<(string, bool)> Fields = new List<(string, bool)>();
        }

        public void Initialize(IncrementalGeneratorInitializationContext initCtx)
        {
            var query = initCtx.SyntaxProvider.CreateSyntaxProvider(
                predicate: (node, _) =>
                {
                    if (!(node is StructDeclarationSyntax structDecl))
                        return false;

                    return structDecl.AttributeLists.Contains("ExplicitCopyApi");
                },
                transform: (ctx, _) =>
                {
                    var c = (StructDeclarationSyntax)ctx.Node;

                    var t = ctx.SemanticModel.GetDeclaredSymbol((StructDeclarationSyntax)ctx.Node);
                    var result = new TypeInfo
                    {
                        TypeName = c.Identifier.ValueText,
                    };

                    if (t == null)
                        return result;

                    result.Namespace = t.ContainingNamespace.ToDisplayString();
                    result.IsUnmanged = t.IsUnmanagedType;
                    result.HasDeallocAttribute = t.GetAttributes().Contains(DeallocApi);

                    var usings = new HashSet<string>();

                    foreach (var m in t.GetMembers())
                    {
                        if (!(m is IFieldSymbol f) || f.IsStatic)
                            continue;

                        if (!(f.Type is INamedTypeSymbol ft))
                            continue;

                        if (ft.GetAttributes().Contains(ExplicitCopyApi))
                        {
                            result.Fields.Add((f.Name, true));
                            usings.Add(ft.ContainingNamespace.ToDisplayString());
                        }
                        else if (ft.GetAttributes().Contains(UnmanagedList))
                        {
                            result.Fields.Add((f.Name, true));
                            usings.Add(ft.ContainingNamespace.ToDisplayString());

                            if (ft.IsGenericOver(ExplicitCopyApi, out var genericType))
                                usings.Add(genericType.ContainingNamespace.ToDisplayString());
                        }
                        else
                        {
                            result.Fields.Add((f.Name, false));
                        }
                    }

                    usings.Add("DnDev");
                    usings.Remove(result.Namespace);
                    result.Usings = usings.ToArray();

                    Array.Sort(result.Usings);

                    return result;
                }
            );

            var collected = query.Collect();

            initCtx.RegisterSourceOutput(collected, (ctx, entries) =>
            {
                var sb = new StringBuilder();

                foreach (var entry in entries)
                {
                    sb.AppendLine("// Generated by DnDev.RefList.Roslyn");

                    if (entry.Namespace == null)
                    {
                        sb.AppendLine($"#error Failed to get a declared symbol for the `{entry.TypeName}`");
                    }
                    else
                    {
                        foreach (var u in entry.Usings)
                            sb.AppendLine($"using {u};");

                        sb.AppendLine();
                        sb.AppendLine($"namespace {entry.Namespace}");
                        sb.AppendLine("{");
                        sb.AppendLine($"    public static class {entry.TypeName}ExplicitCopy");
                        sb.AppendLine("    {");

                        EmitExplicitCopyMethods(sb, entry);
                        EmitUtils.EmitRefListMethods(
                            entry.HasDeallocAttribute ?
                                ExplicitCopyTemplates.RefListExtensionsDealloc :
                                ExplicitCopyTemplates.RefListExtensions,
                            sb,
                            entry.TypeName,
                            entry.IsUnmanged
                        );

                        sb.AppendLine("    }");
                        sb.AppendLine("}");
                    }

                    ctx.AddSource($"{entry.TypeName}ExplicitCopy.g.cs", sb.ToString());
                    sb.Clear();
                }
            });
        }

        private static void EmitExplicitCopyMethods(StringBuilder sb, TypeInfo entry)
        {
            sb.AppendLine($"        public static void CopyFrom(this ref {entry.TypeName} self, in {entry.TypeName} other)");
            sb.AppendLine("        {");

            foreach (var (fn, expCopy) in entry.Fields)
                sb.AppendLine(expCopy
                    ? $"            self.{fn}.CopyFrom(other.{fn});"
                    : $"            self.{fn} = other.{fn};");

            sb.AppendLine("        }");

            sb.AppendLine();

            sb.AppendLine($"        public static void CopyTo(this in {entry.TypeName} self, ref {entry.TypeName} other)");
            sb.AppendLine("        {");
            sb.AppendLine("            other.CopyFrom(self);");
            sb.AppendLine("        }");
        }
    }
}